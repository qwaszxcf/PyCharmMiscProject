{
  "metadata": {
    "source_file": "testdoc.docx",
    "total_chunks": 30,
    "created_at": "2026-01-09T17:26:05.286811"
  },
  "chunks": [
    {
      "chunk_id": "testdoc_chunk_0000",
      "text": "本章通过聚焦于基于网络应用的架构，继续讨论上一章中提出的背景材料，并且描述如何使用架构风格来指导它们的架构设计。",
      "metadata": {
        "title": "第 2 章 基于网络应用的架构",
        "level": 1,
        "chunk_index": 0,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0001",
      "text": "架构可以存在于软件系统的多个层次上。本论文检查了软件架构最高层次上的抽象，在这里能够通过网络通信来实现组件之间的交互。我们将讨论限制在基于网络应用的架构风格之上，这样可以减少需要研究的架构风格之间的差异维度。",
      "metadata": {
        "title": "范围",
        "level": 2,
        "chunk_index": 1,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0002",
      "text": "通常来说，基于网络的架构（network-based architectures）与软件架构（software architectures）的主要区别是：组件之间的通信仅限于消息传递（message passing）或者消息传递的等价物（如果在运行时，基于组件的位置能够选择更有效的机制）。\\nTanenbaum 和 van Renesse  是这样来区分分布式系统（distributed systems）和基于网络系统（network-based systems）的：分布式系统在用户看来好像是普通的集中式系统\\n（centralized system），但是运行在多个独立的 CPU 之上。相反，基于网络的系统有能力跨越网络运行（capable of operation across a network），但是这一点无需表达为对用户透明的方式。在某些情况下，甚至还希望用户知道：一个需要使用网络请求的动作，和一个在他们的本地系统就能满足的动作，两者之间有很大的差别，尤其是当使用网络意味着额外的处理成本的时候 。本论文涵盖了基于网络的系统，并没有局限于那些对用户透明的系统。",
      "metadata": {
        "title": "基于网络 vs. 分布式",
        "level": 3,
        "chunk_index": 2,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0003",
      "text": "对于本论文范围的另外一个限制是我们将讨论范围限制在对应用软件的架构的讨论上，不包括操作系统、网络软件（networking software）和一些仅仅为得到系统支持而使用网络（only use a network for system support）的架构风格 (例如，进程控制风格 process control styles )。应用软件代表的是系统中能够“理解业务”（business-aware）的那部分功能。\\n应用软件的架构是对于整个系统的一种抽象，其中用户动作的目的（the goals of a user action）可以被表示为功能性的架构属性（functional architectural properties）。例如，一个超媒体应用必须关注信息页面的位置、执行请求和对数据流做呈现。这与网络抽象（a networking abstraction）形成了对比，网络抽象之目的是将比特从一个地点移动到另一个地点，而不关心为何要移动这些比特。只有在应用的层面上，我们才能够基于一些因素来评估设计上的权衡，这些因素包括每个用户动作的交互数量、应用状态的位置（the",
      "metadata": {
        "title": "应用软件 vs. 网络软件",
        "level": 3,
        "chunk_index": 3,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0004",
      "text": "location of application state）、所有数据流的有效吞吐量（与单个数据流的潜在吞吐量相对应）、每个用户动作所执行通信的程度（the extent of communication）等等。",
      "metadata": {
        "title": "应用软件 vs. 网络软件",
        "level": 3,
        "chunk_index": 4,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0005",
      "text": "为选择或创建最适合于某一特定应用领域（application domain）的架构提供设计指导，这是本论文的一个目的。请记住架构是架构设计的实现，而并非架构设计本身。我们能够根据一个架构在运行时的特征来对其加以评估，但是很明显我们更希望能够在不得不实现所有的候选架构设计之前，有一种对这些架构设计进行评估的机制。不幸的是，众所周知，很难\\n通过一种客观的方式来对架构设计加以评估和比较。就像大多数其他创造性设计的产物一样，架构通常被展现为一件已经完成的工作，就好像设计是从架构师头脑中完整地流淌出来一样。为了评估一个架构设计，我们需要检查隐藏在置于系统之上的架构约束背后的设计基础理论，并且将因那些架构约束而产生的架构属性与目标应用的目的进行比较。\\n第一个层面的评估由应用的功能需求来设定。例如，针对分布式超媒体系统的需求来对一个进程控制架构（process control",
      "metadata": {
        "title": "评估应用软件架构的设计",
        "level": 2,
        "chunk_index": 5,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0006",
      "text": "control architecture）进行评估是没有意义的，因为如果架构不能正常运转，比较就无实际意义。虽然这样会将一些候选的架构设计排除在外，但是在大多数情况下还是会剩下很多能够满足应用的功能性需求的架构设计。剩下的候选者之间的区别是\\n对非功能需求的强调程度——每个架构都会以不同的程度支持系统必需的各种非功能性架构属性。因为架构属性是由架构约束产生的，所以有可能通过以下方式来评估和比较不同的架构设计：识别出每个架构的架构约束，评估每个架构约束所产生的一组架构属性，并将设计累积的架构属性与那些应用所要求的架构属性加以比较。\\n正如上一章中所描述的，一种架构风格是一组相互协作的架构约束，给它取一个名称是为了便于引用。每一个架构设计决策可以被看作是对一种架构风格的应用。因为添加的一个架构约束可能是从一种新的架构风格获得的，我们可以将所有可能的架构风格的空间看作是一棵继承树（a derivation tree），这棵树的根节点是“空”风格（没有任何架构约束）。当多种架构的架构约束不存在冲突时，它们就可以进行组合，形成一种混合架构风格（a hybrid",
      "metadata": {
        "title": "评估应用软件架构的设计",
        "level": 2,
        "chunk_index": 6,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0007",
      "text": "style），最终可以形成一种代表了架构设计完整抽象的混合架构风格。因此通过将一个架构设计的架构约束集合分解到一棵继承树上，就能够对这个架构设计进行分析，并且可以评估由这棵继承树所代表的架构约束的累积效果。如果我们理解了每种基本架构风格所产生的架构属性，那么遍历这棵继承树可以使我们理解架构设计的全部的架构属性，然后就能够将应用的特定需求与架构设计的架构属性进行匹配。这样比较不同的架构设计就变成了一件相当简单的事情：识别出哪些架构设计满足了该应用的大多数期待的架构属性。\\n必须意识到，一种架构约束的效果可能会抵消一些其他架构约束带来的好处。尽管如此，一个有经验的软件架构师仍然有可能为一个特定应用领域的架构约束建造一棵这样的继承\\n树，然后使用这棵继承树来评估该领域应用的很多不同的架构设计。这样，建造一棵继承树就为架构设计提供了一种评估机制。\\n在一棵架构风格的继承树中对架构属性所进行的评估，是特定于一个特殊应用领域之需求的，因为特定架构约束的影响常常取决于应用的特性。例如，当我们将管道和过滤器架构风格用于要求在组件之间进行数据转换的系统中时，会产生一些积极的架构属性；但是当系统仅仅由控",
      "metadata": {
        "title": "评估应用软件架构的设计",
        "level": 2,
        "chunk_index": 7,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0008",
      "text": "过滤器架构风格用于要求在组件之间进行数据转换的系统中时，会产生一些积极的架构属性；但是当系统仅仅由控制消息（control",
      "metadata": {
        "title": "评估应用软件架构的设计",
        "level": 2,
        "chunk_index": 8,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0009",
      "text": "messages）组成时，它只会增加系统的开销（overhead），而不会带来任何好处。因为跨不同的应用领域对架构设计进行比较用处不大，因此确保一致性的最简单的方法是使这棵继承树特定于某个领域。\\n对架构设计做评估往往是一个在不同的权衡点之间进行选择的问题，Perry 和 Wolf 描述了一种明确地识别权衡点的方法，给每个架构属性加上一个数字权重，表明它在架构中的相对重要性，这样就提供了对候选设计进行比较的标准度量手段。然而，为了让权重成为一个有意义的度量手段，必须使用一种对于所有架构属性一致的客观尺度来小心地选取每个权重。实际上，这样的尺度是不存在的。与其让架构师不断调整权重，直到结果与他们的直觉匹配，我更愿意将所有的信息用容易看到的形式展示给架构师，通过视觉上的模式来指导架构师的直觉。这将会在下一章中进行演示。",
      "metadata": {
        "title": "评估应用软件架构的设计",
        "level": 2,
        "chunk_index": 9,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0010",
      "text": "本节描述了多种架构属性，它们将用于对本论文中的架构风格进行区别和分类。我并没有想要列出一份全面的清单，而是根据我所调查的一组架构风格，只列出了那些明显受到这\\n些架构风格影响的架构属性。其他的架构属性，有时候也被称作软件质量（software qualities），在大多数软件工程的教科书中都会涉及到（例如 ）。Bass 等人检查了与软件架构有关的质量。",
      "metadata": {
        "title": "关键关注点的架构属性",
        "level": 2,
        "chunk_index": 10,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0011",
      "text": "聚焦于基于网络应用的架构风格的主要原因之一，是因为组件交互（component interactions）对于用户感知的性能（user-perceived performance）和网络效率（network efficiency）来说是一个决定性因素。由于架构风格影响到这些交互的特性，选择合适的架构风格能够决定基于网络应用部署的成败。\\n基于网络应用的性能首先取决于应用的需求，然后是所选择的交互风格，接下来是实现架构（the realized architecture），最后是每个组件的实现。换句话说，应用软件无法回避为了实现该软件的需求而付出的基本成本；例如，如果应用软件需要数据位于系统 A，并由系统 B 来处理，那么该软件无法避免将数据从系统 A 移动到系统 B。同样地，架构无法超越其交互风格所允许的最高效率。例如，将数据从系统 A 移动到系统 B 的多次交互的成本不可能少于单独一次从系统 A 到系统 B 的交互。最后，无论架构的质量如何，交互的速度再快，也不可能比组件生产数据加上接收者消费数据所需要的总时间更快。",
      "metadata": {
        "title": "性能（Performance）",
        "level": 3,
        "chunk_index": 11,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0012",
      "text": "网络性能这个度量手段用来描述通信的某些属性。吞吐量（throughput）是信息（既包括应用的数据也包括通信的开销）在组件之间移交的速率。开销（overhead）可分为初始化开销（initial setup overhead）和每次交互（都会产生的）开销（per-interaction overhead），这种区分有助于识别出能够跨多次交互共享（分摊 amortization）初始化开销的连接器。带宽\\n（bandwidth）是在特定网络连接上可用的最大吞吐量。可用带宽（usable bandwidth）是指应用实际可用的那部分带宽。\\n架构风格对于网络性能的影响是通过影响每个用户动作的交互数量和数据元素的粒度来实现的。鼓励小型的、强类型（strongly typed）的交互的架构风格，对于仅需在已知组件之间移交小型数据（small data transfers among known components）的应用来说会很有效率，但是会在需要移交大型数据或协商接口（large data transfer or negotiated",
      "metadata": {
        "title": "网络性能（Network Performance）",
        "level": 4,
        "chunk_index": 12,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0013",
      "text": "data transfer or negotiated interfaces）的应用中导致过多的开销。同样地，一种需要通过多个组件之间协作来过滤大型数据流的架构风格，在主要需要小型控制消息（small control messages）的应用中也会显得不合时宜。",
      "metadata": {
        "title": "网络性能（Network Performance）",
        "level": 4,
        "chunk_index": 13,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0014",
      "text": "用户感知的性能（user-perceived performance）与网络性能（network performance）的区别是，根据一个动作对于使用应用的用户的影响来度量这个动作的性能，而不是根据网络移动信息的速率来度量。用户感知的性能的主要度量手段是延迟（latency）和完成时间\\n（completion time）。\\n延迟（latency）是指从最初的触发请求（initial stimulus）到得到最的响应指示（the first indication of a response）之间持续的时间。延迟会发生在基于网络应用的处理过程中如下几个点上：1) 应用对于触发动作的事件的反应时间；2) 在组件之间建立交互所需的时间；3) 将交互请求数据传输到每个组件所需的时间；4) 在那些组件上处理每个交互请求所需的时间；以及 5)",
      "metadata": {
        "title": "用户感知的性能（User-perceived Performance）",
        "level": 4,
        "chunk_index": 14,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0015",
      "text": "将交互请求数据传输到每个组件所需的时间；4) 在那些组件上处理每个交互请求所需的时间；以及 5) 应用能够对可用结果做呈现之前，完成移交和处理交互结果数据所需的时间。重要的是要注意到：虽然只有在第(3)点和第(5)点中存在着真正的网络通讯，但是架构风格对以上所有五点都会产生影响。此外，每个用户动作的多次组件交互也会增加延迟，除非它们能够并行发生（take place in parallel）。\\n完成时间（completion）是完成一个应用动作所花费的时间。完成时间取决于所有上述的延迟点。动作的完成时间和它的延迟之间的区别在于，延迟代表了一种应用能够增量地处理正在接收数据的程度。例如，一个能够在接收数据的同时显示一个大型图片的 Web 浏览器，与等待全部数据接收完之后才能显示图片的 Web",
      "metadata": {
        "title": "用户感知的性能（User-perceived Performance）",
        "level": 4,
        "chunk_index": 15,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0016",
      "text": "Web 浏览器，与等待全部数据接收完之后才能显示图片的 Web 浏览器相比，前者的用户感知的性能会比后者好得多，即使两者具有相同的网络性能。\\n重要的是要注意到：对延迟进行优化的设计常常会产生延长完成时间的副作用，反之亦然。例如，如果所用算法在对数据进行编码之前，对其重要部分进行采样，那么对这段数据流的压缩就能够得到更高的编码效率。对于跨越网络移交已编码的数据来说，这样就会得到更短的完成时间。然而，如果压缩是在响应用户动作的过程中以一种即时（on-the-fly）的方式来执行的，在移交之前缓存大型的采样数据会产生不可接受的延迟。在这些权衡点之间取得平衡是很困难的，特别是当不知道接收者是更关心延迟（例如，Web 浏览器）还是更关心完成时间（例如，Web 爬虫）的时候。",
      "metadata": {
        "title": "用户感知的性能（User-perceived Performance）",
        "level": 4,
        "chunk_index": 16,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0017",
      "text": "我们观察到，基于网络应用的一个有趣现象是：最佳的应用性能是通过不使用网络而获得的。这意味着对于基于网络应用来说，只有在可能的情况下有效地将对于网络的使用减到最少，才是最高效的架构风格。可以通过重用先前的交互（缓存）、减少与用户动作相关的网络交互（复制数据和关闭连接操作）、或者通过将对数据的处理移到距离数据源更近的地方（移动代码）来减小某些交互的必要性。\\n各种性能问题的影响常常与应用的分布范围有关。在局部情况（local conditions）下一种架构风格所具有的优点，在面对全局情况（global conditions）时也许却会变成缺点。因此架构风格的属性必须受到与交互距离相关的限制：在单个进程中还是在单个机器上的多个进程之间、在一个区域网（LAN）内还是分布在广域网（WAN）上。当交互跨越广域网时，还会有一个明显的额外关注点：是只涉及一个组织的交互，还是涉及多个组织的信任边界（trust boundaries）的跨互联网交互。",
      "metadata": {
        "title": "网络效率（Network Efficiency）",
        "level": 4,
        "chunk_index": 17,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0018",
      "text": "可伸缩性表示通过主动的配置（within an active configuration），一个架构支持大量的组件或大量组件之间的交互的能力。我们能够通过以下方法来改善可伸缩性：简化组件、将服务分布到很多组件（对交互去中心化）、以及根据监视获得的信息对交互和配置加以控制。架构风格可以通过确定应用状态的位置、分布的范围以及组件之间的耦合度，来影响上述这些因素。\\n可伸缩性还受到以下几个因素的影响：交互的频率、组件负载（the load on a\\ncomponent）随时间的分布是平均的还是存在峰值、交互是保证送达（guaranteed delivery）还是只需要尽量送达（best-effort）、一个请求是否包括同步或异步处理、以及环境是受控的还是无法控制的（即，你是否可以信任其他组件？）。",
      "metadata": {
        "title": "可伸缩性（Scalability）",
        "level": 3,
        "chunk_index": 18,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0019",
      "text": "通过架构风格产生简单性属性的主要方法是，对组件之间的功能分配应用分离关注点原则（principle of separation of concerns）。如果功能分配使得单独的组件足够简单，那么理解和实现这些组件就会更加容易。同样地，这样的关注点分离也使得关于整体架构的推理任务（the\\ntask of reasoning about the overall architecture）变得更加容易。我选择将复杂性（complexity）、可理解性（understandability）和可验证性（verifiability）统一在简单性这个通用的架构属性中，\\n因为它们在基于网络的系统中有着密切的关联。\\n对架构元素应用通用性原则（principle of generality）有助于提高简单性，因为它减少了架构中的变数。对连接器应用通用性原则就产生了中间件。",
      "metadata": {
        "title": "简单性（Simplicity）",
        "level": 3,
        "chunk_index": 19,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0020",
      "text": "可修改性是对于应用的架构作出改变的容易程度。可修改性能够被进一步分解为下面所描述的可进化性、可扩展性、可定制性、可配置性和可重用性。基于网络的系统的一个特殊关注点是动态的可修改性，它要求在对一个已部署的应用作出改变时，无需停止和重新启动整个系统。\\n即使有可能建造一个与用户的需求完美匹配的软件系统，那些需求也会随时间而发生变化，就像社会的变化一样。因为基于网络应用中的组件可能会跨多个组织的边界来分布，系统必须准备好应对逐渐的和片段的改变（gradual and fragmented change），一些旧的组件实现将会与一些新的组件实现共存，而不会妨碍新的组件实现使用它们自己的扩展功能。",
      "metadata": {
        "title": "可修改性（Modifiability）",
        "level": 3,
        "chunk_index": 20,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0021",
      "text": "可进化性代表了能够改变一个组件实现而不会对其他组件产生负面影响的程度。组件的静态进化（static evolution）通常依赖于其实现对架构抽象的增强程度，因此这并非是任何特定架构风格所独有的。然而，如果在某种架构风格中包括了关于维护（maintenance）和应用状态位置（location of application state）的架构约束，该架构风格会对动态进化（dynamic evolution）产生影响。在分布式系统中用来从局部故障状况中恢复（recover from partial failure conditions）的相同技术  也能够用于支持动态进化。",
      "metadata": {
        "title": "可进化性（Evolvability）",
        "level": 4,
        "chunk_index": 21,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0022",
      "text": "可扩展性被定义为将功能添加到一个系统中的能力 。动态可扩展性意味着能够将功能添加到一个已部署的系统中，而不会影响到系统的其他部分。产生可扩展性的方法是在一个架构中减少组件之间的耦合，就像基于事件的集成（event-based intergration）架构风格展示的那样。",
      "metadata": {
        "title": "可扩展性（Extensibility）",
        "level": 4,
        "chunk_index": 22,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0023",
      "text": "可定制性是指临时性地规定一个架构元素的行为的能力，随后该元素能够提供一种非常规的服务。如果一个组件的客户端能够扩展该组件的服务，而不会对该组件的其他客户端产生影响，则该组件就是可定制的 。支持可定制性的架构风格也可能会提高简单性和可伸缩性，这是因为通过仅仅直接实现最常用的服务，允许客户端来定义不常用的服务，将会降低服务组件（service components）的尺寸和复杂性。可定制性是通过使用远程求值（remote evaluation）架构风格和按需代码（code-on-demand）架构风格而产生的一种架构属性。",
      "metadata": {
        "title": "可定制性（Customizability）",
        "level": 4,
        "chunk_index": 23,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0024",
      "text": "可配置性既与可扩展性有关，也与可重用性有关，因为它是指对于组件或者组件的配置在部署之后做修改（post-deployment modification）的能力，这样组件能够使用新的服务或者新的数据元素类型。例如，管道和过滤器和按需代码两种架构风格可以分别为组件及其配置产生可配置性。",
      "metadata": {
        "title": "可配置性（Configurability）",
        "level": 4,
        "chunk_index": 24,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0025",
      "text": "可重用性是应用架构的一个属性，如果一个应用架构中的组件、连接器或数据元素能够在不做修改的情况下在其他应用中重用，那么该架构就具有可重用性。在架构风格中产生可重用性的主要机制是降低组件之间的耦合（一个组件知道其他组件的标识）和强制使用通用的组件接口。统一管道和过滤器架构风格中包括了这两种架构约束。",
      "metadata": {
        "title": "可重用性（Reusability）",
        "level": 4,
        "chunk_index": 25,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0026",
      "text": "通过通用性架构约束来限制交互的接口（restricting interfaces via generality），或者提供访问功能以便于监视（providing access to monitoring），架构风格也能够影响基于网络应用中交互的可见性。在这种情况下，可见性是指一个组件对于其他两个组件之间的交互进行监视或进行中间斡旋（monitor or mediate）的能力。拥有了可见性之后，就能够通过多个交互共享的缓存来改善性能、通过分层服务来改善可伸缩性、通过反射式监视（reflective monitoring）来改善可靠性、通过允许中间组件（例如，网络防火墙）对交互做检查来改善安全性。缺乏\\n可见性可能会导致安全问题，移动代理（mobile agent）架构风格就是一个例子。\\n这种对于术语“可见性”的使用方法与 Ghezzi 等人的使用方法存在着区别，他们所说\\n的可见性是对开发过程而言的，而非对产品而言的。",
      "metadata": {
        "title": "可见性（Visibility）",
        "level": 3,
        "chunk_index": 26,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0027",
      "text": "如果软件能够在不同的环境下运行，软件就是可移植的 。能够产生可移植性架构属性的架构风格包括那些将代码和代码处理的数据放在一起移动的架构风格，例如虚拟机\\n（virtual machine）架构风格和移动代理（mobile agent）架构风格；以及那些限制只能使用标准格式的数据元素的架构风格。",
      "metadata": {
        "title": "可移植性（Portability）",
        "level": 3,
        "chunk_index": 27,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0028",
      "text": "从应用的架构角度来说，可靠性可以被看作当在组件、连接器或数据之中出现部分故障时，一个架构容易受到系统层面故障影响的程度。架构风格能够通过以下方法来改善可靠性：避免单点故障、增加冗余、允许监视、以及将故障的范围缩小到一个可恢复的动作（reducing the scope of failure to a recoverable action）。",
      "metadata": {
        "title": "可靠性（Reliability）",
        "level": 3,
        "chunk_index": 28,
        "source": "testdoc.docx"
      }
    },
    {
      "chunk_id": "testdoc_chunk_0029",
      "text": "通过聚焦于基于网络应用的架构，并且描述如何使用架构风格来指导这些架构的设计，本章对本论文所涉及到的范围进行了检查。本章还定义了架构属性的集合，在本论文的剩余部分中，将使用这些架构属性来对架构风格进行比较和评估。\\n下一章将会在一个分类框架中，调查一些常见的基于网络应用的架构风格。当将架构风格应用于基于网络的超媒体系统的架构时，将会产生一系列架构属性。这个分类框架根据这些架构属性，来对每一种架构风格进行评估。",
      "metadata": {
        "title": "小结",
        "level": 2,
        "chunk_index": 29,
        "source": "testdoc.docx"
      }
    }
  ]
}